<!DOCTYPE html>
<meta charset="utf-8">
<style>

body {
  background: #fff
}

.land {
  fill: #222;
}

.mesh {
  fill: none;
  stroke: #222;
  stroke-width: 1px;
}

.mesh.important {
  stroke: rgb(162,55,33)
}

.hidden {
  display: none
}

.states {
  fill: none;
  stroke: #fff;
  stroke-width: 1px;
}

.overlay {
  fill: none;
  pointer-events: all;
}

.player {
  fill: rgb(166,189,219);
}

.player.active {
  fill: rgb(43,140,190);
}


.q0-9{fill:rgb(255,247,236)}
.q1-9{fill:rgb(254,232,200)}
.q2-9{fill:rgb(253,212,158)}
.q3-9{fill:rgb(253,187,132)}
.q4-9{fill:rgb(252,141,89)}
.q5-9{fill:rgb(239,101,72)}
.q6-9{fill:rgb(215,48,31)}
.q7-9{fill:rgb(179,0,0)}
.q8-9{fill:rgb(127,0,0)}

div.tooltip {
  position: absolute;
  text-align: center;
  width: 200px;
  height: 80px;
  padding: 2px;
  font: 12px sans-serif;
  background: lightsteelblue;
  border: 0px;
  border-radius: 8px;
  pointer-events: none;
}

</style>
<body>
<script src="lib/d3.v3.min.js"></script>
<script src="lib/queue.v1.min.js"></script>
<script src="lib/topojson.v1.min.js"></script>
<script src="lib/lodash.min.js"></script>
<script>
'use strict'

var width = 960,
    height = 960,
    active = d3.select(null);

var playerLocations;
var totalPlayers = 0;


/*
var quantize = d3.scale.quantize()
    .domain([1, 150])
    //.range(d3.scale.category20().range());
    .range(d3.range(0,9).map(function(i) { return "q" + i + "-9"; }));
    */

var logscale = d3.scale.log()
    .domain([1, 400])
    .range([0,1]);

var linearscale = d3.scale.quantize()
    .domain([0, 1])
    .range(d3.range(9).map(function(i) { return "q" + i + "-9"; }));

var quantize = function(d) {
  return linearscale( logscale ( d ) );
}

var projection = d3.geo.mercator()
   .scale((width + 1) / 2 / Math.PI)
    .translate([width / 2, height / 2])
    .precision(.1);

var zoom = d3.behavior.zoom()
    .translate([0, 0])
    .scale(1)
    .scaleExtent([1, 20])
    .on("zoom", zoomed);

var path = d3.geo.path()
    .projection(projection);


var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height)
    .on("click", stopped, true);

var tooltipDiv = d3.select("body").append("div")
    .attr("class", "tooltip")
    .style("opacity", 0);

var features_g = svg.append("g");
var players_g;

svg.call(zoom).call(zoom.event);


queue()
    .defer(d3.json, "data/world.json")
    .defer(d3.json, "data/playerProfilesWithGeo.json")
    .await(ready);

function ready(error, world, playerData) {
  playerLocations = makePlayerMap(playerData);

  var countryFeatures = topojson.feature(world, world.objects.countries).features;
  var stateFeatures = topojson.feature(world, world.objects.states).features;

   features_g.append("g")
        .attr("class", "land")
      .selectAll("path")
        .data(countryFeatures)
      .enter().append("path")
        .attr("class", function(d) {
          var count = (playerLocations.get(d.id) || {}).count;
          return quantize(count);
        })
        .attr("d", path)
        .on("click", clicked);

  function importantMesh(a, b) {
    return (playerLocations.has(a.id) || playerLocations.has(b.id));
  }

  features_g.append("path")
      .datum(topojson.mesh(world, world.objects.countries, function(a, b) { return importantMesh(a,b) }))
      .attr("class", "mesh important")
      .attr("d", path);

  features_g.append("path")
      .datum(topojson.mesh(world, world.objects.countries, function(a, b) { return !importantMesh(a,b); }))
      .attr("class", "mesh")
      .attr("d", path);


  features_g.append("g")
      .attr("class", "states")
    .selectAll("path")
      .data(stateFeatures)
    .enter().append("path")
      .attr("class", function(d) {
        return "hidden " + d.id;
      })
      .attr("d", path);

  //ensure players get drawn on top
  players_g = features_g.append("g").attr("class", "players");
  showAllPlayers();
}


function makePlayerMap(players) {
  var locations = d3.map();

  _.each(players, function (p) {
    if( p.geo.status !== 'OK' ) return;

    var geo = p.geo.results[0];

    var country = _.find(geo.address_components, function(g) {
        return _.contains(g.types, 'country');
    });


    var state = _.find(geo.address_components, function(g) {
        return _.contains(g.types, 'administrative_area_level_1');
    });

    if(country) {
      var key;

      var countryName = country.short_name;
      if( countryName !== 'US' && countryName !== 'CA' ) {
        key = countryName;
      } else {
        //key = state.long_name;
        key = countryName;
      }

      var loc = locations.get(key) || {};
      var players = loc.players || [];
      var count = loc.count || 0;

      players.push({
        name: p.name,
        location: geo.geometry.location,
        country: countryName,
        birthday: p.birthday,
        town: p.birthplace,
        team: p.currentTeam,
        position: p.position
      })

      locations.set(key, {
        name: key,
        count: count+=1,
        players: players
      });
    }

  });

  return locations;
}


function zoomed() {
  if(players_g) {
    players_g.selectAll('circle').attr("r", 4 / d3.event.scale);
  }

  features_g.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
  features_g.selectAll(".mesh").style("stroke-width", 1 / d3.event.scale + "px");
  features_g.select(".states").style("stroke-width", 1 / d3.event.scale + "px");
}


function clicked(d) {
  if (active.node() === this) return reset();
  if( !playerLocations.has(d.id)) return; //disable zoom if there are no players
  if(active.node()) d3.selectAll("."+active.datum().id).classed("hidden", true);

  players_g.selectAll("circle").classed("active", false);

  active.classed("active", false);

  active = d3.select(this).classed("active", true);
  d3.selectAll("."+d.id).classed("hidden", false);


  var bounds = path.bounds(d),
      dx = bounds[1][0] - bounds[0][0],
      dy = bounds[1][1] - bounds[0][1],
      x = (bounds[0][0] + bounds[1][0]) / 2,
      y = (bounds[0][1] + bounds[1][1]) / 2,
      scale = .9 / Math.max(dx / width, dy / height),
      translate = [width / 2 - scale * x, height / 2 - scale * y];

/*
  svg.transition()
      .duration(750)
      .call(zoom.translate(translate).scale(scale).event);
      */

  showPlayersFor(d.id);
}

function showAllPlayers() {
  showPlayers(_.chain(playerLocations.values()).pluck('players').flatten().value())
}

function showPlayersFor(country) {
  players_g.selectAll("circle")
           .filter(function(d) {
              return d.country === country;
           })
           .classed("active", true);
}

function showPlayers(players) {
  players_g
    .selectAll("circle")
    .data(players)
    .enter().append("circle")
    /*
    .attr("cx", function (d) {
      return width / 2;
    })
    .attr("cy", function (d) {
      return 0;
    })
    */
    .attr("cx", function (d) {
      var loc = d.location;
      return projection([loc.lng, loc.lat])[0];
    })
    .attr("cy", function (d) {
      var loc = d.location;
      return projection([loc.lgn, loc.lat])[1];
    })
    .attr("class", "player")
    .attr("r", 0)
    .on("mouseover", function(d) {
      tooltipDiv.transition()
          .duration(200)
          .style("opacity", .9);
      tooltipDiv.html(tooltipFor(d))
          .style("left", (d3.event.pageX) + "px")
          .style("top", (d3.event.pageY - 28) + "px");
    })
    .on("mouseout", function(d) {
      tooltipDiv.transition()
          .duration(500)
          .style("opacity", 0);
    })
    .transition().duration(1000).delay(500)
    .attr("r", 4 / zoom.scale())
}

function tooltipFor(d) {
  return [d.name, d.birthday, d.town, d.position, d.team].join('<br/>');

}
function reset () {
  active.classed("active", false);
  d3.selectAll("."+active.datum().id).classed("hidden", true);
  players_g.selectAll("circle").classed("active", false);


  active = d3.select(null);

  svg.transition()
      .duration(750)
      .call(zoom.translate([0, 0]).scale(1).event);
}

// If the drag behavior prevents the default click,
// also stop propagation so we donâ€™t click-to-zoom.
function stopped() {
  if (d3.event.defaultPrevented) d3.event.stopPropagation();
}


d3.select(self.frameElement).style("height", height + "px")</script>
