<!DOCTYPE html>
<meta charset="utf-8">
<style>

body {
  background: #000
}

.land {
  fill: rgb(48,52,56);
}

.mesh {
  fill: none;
  stroke: #000;
  stroke-width: 1px;
}

.hidden {
  display: none
}

.states {
  fill: none;
}

.overlay {
  fill: none;
  pointer-events: all;
}

.player {
  fill: rgb(166,189,219);
  cursor: pointer;
}

.player.selected {
  stroke: yellow;
  stroke-width: .25px;
}

.player.active {
  fill: rgb(43,140,190);
}


.q0-9{fill:rgb(255,247,236)}
.q1-9{fill:rgb(254,232,200)}
.q2-9{fill:rgb(253,212,158)}
.q3-9{fill:rgb(253,187,132)}
.q4-9{fill:rgb(252,141,89)}
.q5-9{fill:rgb(239,101,72)}
.q6-9{fill:rgb(215,48,31)}
.q7-9{fill:rgb(179,0,0)}
.q8-9{fill:rgb(127,0,0)}

div.tooltip {
  position: absolute;
  text-align: center;
  width: 200px;
  height: 80px;
  padding: 2px;
  font: 12px sans-serif;
  background: lightsteelblue;
  border: 0px;
  border-radius: 8px;
  pointer-events: none;
}

</style>
<body>
<script src="lib/d3.v3.min.js"></script>
<script src="lib/queue.v1.min.js"></script>
<script src="lib/topojson.v1.min.js"></script>
<script src="lib/lodash.min.js"></script>
<script>
'use strict'

var APP = function () {
  var app = this;
  app.width = 960;
  app.height = 960;
  app.playerSize = 4;
  app.active = d3.select(null);

  app.f = {
    init: function (error, world, playerData) {
      app.playerLocations = makePlayerMap(playerData);

      var svg = app.svg = d3.select("body").append("svg")
          .attr("width", app.width)
          .attr("height", app.height)
          .on("click", app.f.behaviors.stopped, true);

      app.tooltipDiv = d3.select("body").append("div")
          .attr("class", "tooltip")
          .style("opacity", 0);

      var features_g = app.features_g = svg.append("g");
      app.land_g = features_g.append("g").attr("class", "land");
      app.states_g = features_g.append("g").attr("class", "states");
      app.players_g = features_g.append("g").attr("class", "players");

      app.f.drawMap(world);
      app.f.drawPlayers();

      svg.call(app.zoom).call(app.zoom.event);
    },


    drawMap: function(world) {
      var countryFeatures = topojson.feature(world, world.objects.countries).features;
      var stateFeatures = topojson.feature(world, world.objects.states).features;


      app.projection =  d3.geo.mercator()
                          .scale((app.width + 1) / 2 / Math.PI)
                          .translate([app.width / 2, app.height / 2])
                          .precision(.1);


      app.zoom =  d3.behavior.zoom()
                    .translate([0, 0])
                    .scale(1)
                    .scaleExtent([1, 500])
                    .on("zoom", app.f.behaviors.zoom);

      var path = d3.geo.path()
          .projection(app.projection);

      var land = app.land_g;
      var states = app.states_g;

      land.selectAll("path")
          .data(countryFeatures)
          .enter().append("path")
          .attr("d", path);

      land.append("path")
          .datum(topojson.mesh(world, world.objects.countries))
          .attr("class", "mesh")
          .attr("d", path);


    //TODO fix the states, show all of US and canada?
    states.selectAll("path")
          .data(stateFeatures)
          .enter().append("path")
          .attr("class", function(d) {
            return "hidden " + d.id;
          })
          .attr("d", path);

    states.append("path")
          .datum(topojson.mesh(world, world.objects.states))
          .attr("class", "mesh")
          .attr("d", path);

    },


    drawPlayers: function () {
      //TODO make this data static before runtime
      var players = _.chain(app.playerLocations.values()).pluck('players').flatten().value();
      var projection = app.projection;

      app.players_g
        .selectAll("circle")
        .data(players)
        .enter().append("circle")
        .attr("cx", function (d) {
          var loc = d.location;
          return projection([loc.lng, loc.lat])[0];
        })
        .attr("cy", function (d) {
          return -20;
        })
        .attr("class", "player")
        .attr("r", app.playerSize / app.zoom.scale())
        .on("mouseover", function(d) {
          /*
          tooltipDiv.transition()
              .duration(200)
              .style("opacity", .9);
          tooltipDiv.html(tooltipFor(d))
              .style("left", (d3.event.pageX) + 30 + "px")
              .style("top", (d3.event.pageY - 28) + "px");
              */
        })
        .on("mouseout", function(d) {
          /*
          tooltipDiv.transition()
              .duration(500)
              .style("opacity", 0);
              */
        })
        .on("click", app.f.behaviors.playerClicked)
        .transition().duration(2000)
        .delay(function(d, i) { return (i * 10) + 750; })
        //.delay(750)
        /*
        .delay(function () {
          return app.f.randomIntFromInterval(500, 1500);
        })
        */
        .attr("cx", function (d) {
          var loc = d.location;
          return projection([loc.lng, loc.lat])[0];
        })
        .attr("cy", function (d) {
          var loc = d.location;
          return projection([loc.lgn, loc.lat])[1];
        })
    },


    showPlayersFor: function (country) {
      app.players_g.selectAll("circle")
               .filter(function(d) {
                  return d.country === country;
               })
               .classed("active", true);
    },



    randomIntFromInterval: function (min,max) {
        return Math.floor(Math.random()*(max-min+1)+min);
    },


    behaviors: {

      zoom: function () {
        var players_g = app.players_g,
            features_g = app.features_g;
        players_g.selectAll('circle').attr("r", app.playerSize / d3.event.scale);
        features_g.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
        features_g.selectAll(".mesh").style("stroke-width", 1 / d3.event.scale + "px");
        features_g.select(".states").style("stroke-width", 1 / d3.event.scale + "px");
      },



      playerClicked: function (d) {
        var active = app.active;
        if (active.node() === this) return app.f.behaviors.reset();

        app.players_g.selectAll("circle").classed("active selected", false);

        active.classed("active", false);

        app.active = d3.select(this).classed("active selected", true);

        var loc = d.location,
            proj = app.projection([loc.lng, loc.lat]),
            x = proj[0],
            y = proj[1],
            scale = Math.max(app.zoom.scale(), 7),
            translate = [app.width / 2 - scale * x, app.height / 2 - scale * y];

        app.svg.transition()
                .duration(750)
                .call(app.zoom.translate(translate).scale(scale).event);

        app.f.showPlayersFor(d.country);
      },



      reset: function () {
        app.players_g.selectAll("circle").classed("active selected", false);
        app.active.classed("active selected", false);


        app.active = d3.select(null);

        app.svg.transition()
            .duration(750)
            .call(app.zoom.translate([0, 0]).scale(1).event);
      },

      // If the drag behavior prevents the default click,
      // also stop propagation so we donâ€™t click-to-zoom.
      stopped: function () {
        if (d3.event.defaultPrevented) d3.event.stopPropagation();
      }

    }

  }


}

var app;
queue()
    .defer(d3.json, "data/world.json")
    .defer(d3.json, "data/playerProfilesWithGeo.json")
    .await( function ready(error, world, players) {
      app = new APP();
      app.f.init(error, world, players);
      d3.select(self.frameElement).style("height", app.height + "px")
    })

function makePlayerMap(players) {
  var locations = d3.map();

  _.each(players, function (p) {
    if( p.geo.status !== 'OK' ) return;

    var geo = p.geo.results[0];

    var country = _.find(geo.address_components, function(g) {
        return _.contains(g.types, 'country');
    });


    var state = _.find(geo.address_components, function(g) {
        return _.contains(g.types, 'administrative_area_level_1');
    });

    if(country) {
      var key;

      var countryName = country.short_name;
      if( countryName !== 'US' && countryName !== 'CA' ) {
        key = countryName;
      } else {
        //key = state.long_name;
        key = countryName;
      }

      var loc = locations.get(key) || {};
      var players = loc.players || [];
      var count = loc.count || 0;

      players.push({
        name: p.name,
        location: geo.geometry.location,
        country: countryName,
        birthday: p.birthday,
        town: p.birthplace,
        team: p.currentTeam,
        position: p.position
      })

      locations.set(key, {
        name: key,
        count: count+=1,
        players: players
      });
    }

  });

  return locations;
}






</script>
